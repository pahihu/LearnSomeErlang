
size/1   - tuple/byte/bit size
tuple_size/1   {4,2}
byte_size/1    <<"42">>
bit_size/1     <<101010>>

f(X) when cond1; cond2; ...   % any cond succeeds
f(X) when cond1, cond2, ...   % all cond must succeed


% Guards
is_atom(X)
   hello, 'hello'
is_float(X)
   1.2 3.0e10
is_integer(X)
   42 $a 16#2A 2#101010
is_list(X)
   [alpha, 2]
is_number(X)
is_pid(X)
is_port(X)
is_reference(X)
is_tuple(X)
   {1, 2, 3}


% also allowed in guards
float round trunc
hd tl length

self()
   current process Pid
element(N,T)
   nth element of tuple
size(T)
   numelts in tuple


% guard operations
X > Y
X < Y
X =< Y
X >= Y
X == Y
X /= Y
X =:= Y
X =/= Y


% arithmetic ops
+X
-X
X * Y
X / Y
X div Y
X rem Y
X band Y
X + Y
X - Y
X bor Y
X bxor Y
X bsl Y
X bsr Y


atom_to_list float_to_list integer_to_list
list_to_atom list_to_float list_to_integer
hd tl length

% Process dictionary

put([Key, Val]) -> OldVal
get() -> Dict
get(Key) -> Val
erase() -> Dict
erase(Key) -> OldVal
get_keys() -> LstKeys
get_keys(Val) -> LstKeys

% Processes, Messages
Pid = spawn(module, fn, [args])
Pid = spawn(node, module, fn, [args])

% !!! NO GUARANTEE OF MESSAGE DELIVERY !!!
Pid ! Expr

% Registered names on local nodes
register(Name, Pid)
unregister(Name)
whereis(Name)

{Name, Node} ! Expr

receive
   Msg1 [when Guard1] -> Act1;
   ...
   MsgN [when Guard1] -> ActN;
after
   TimeOut -> ActT
end


% Code loading

load_file(Module)
% module loaded replaces existing module that is made old
% any other copies removed from memory

delete(Module)
% makes Module old, new invocations will not be able to access
% the deleted module

purge(Module)
% removed code of the named module marked as old
% processes running the old module code will be killed

soft_purge(Module)
% similar to purge except it will not purge a module if
% it is currently been used

is_loaded(Module)
% {file, Path|preloaded|interpreted}


% Style
Modules
- minimise the number of functions exported from a module
      reduces module coupling
- use functions to encapsulate common code
      avoid cut&paste programming
- do not presume that the data structures provided by a module
  are unchanging
      avoid direct access
- use interface functions
      avoid sending messages directly

Functions
- avoid side effects
- do not assume what the user of a function wants to do with its
  results
      eg. do not display error messages

Messages
- tag messages
      reduces the sensitivity of msgs to order
- dispose of unknown messages
      every server should incorporate a match all pattern
      in at least one of its receives

General
- avoid defensive programming
- separate handling of error cases from normal code
- write declarative code
      use guards in function heads where possible,
      instead of if/case operations

observer:start().
error_logger:info_msg/warning_msg/error_msg/2
error_logger:logfile/1
debugger:start()

dbg:tracer()
dbg:p(Pid,m)   % messages
dbg:p(all,c)   % calls
dbg:tpl(M,F,A)
dbg:stop()
dbg:stop_clear()


Moving beyond the Erlang shell
------------------------------
- make module, Emakefile, erl -make
https://erlang.org/doc/man/escript.html  escript
https://www.rebar3.org  rebar3
https://erlide.org  erlide


Input and Output
----------------
- file, filename, filelib, io_lib modules
- gen_tcp, gen_udp, inet modules


Testing, Analyzing, and Refactoring
-----------------------------------
- EUnit framework for unit testing, Common Test framework for system testing
- Dialyzer, the discrepancy analyzer
- profilers and coverage tools: eprof, fprof, cover modules, cprof tool
https://github.com/RefactoringTools/wrangler  Wrangler - refactoring


Networking and the Web
----------------------
https://github.com/ninenines/cowboy  Cowboy - webserver
http://yaws.hyber.org  Yaws - webserver
https://github.com/mochi/mochiweb  MochiWeb
   lib for building lightweight HTTP servers
https://nitrogenproject.com  Nitrogen Web Framework
   develop interactive web apps in full-stack Erlang
https://github.com/basho/webmachine/  webmachine
   REST-based system for building web apps
https://github.com/basho/webmachine/wiki/Diagram  webmachine flow processing


Data Storage
------------
https://couchdb.apache.org  CouchDB
https://riak.com/products/#riak  Riak


Extending Erlang
----------------
`Erlang Programming' explores Java, C, Ruby, also notes approaches to connect
with .NET languages, Python, Perl, PHP, Haskell, Scheme, and Emacs Lisp.


Languages Built on Erlang
-------------------------
http://elixir-lang.org  Elixir
   dynamic, functional language
https://lfe.io  LFE - Lisp Falvoured Erlang


https://github.com/drobakowski/awesome-erlang   Awesome Erlang (2018)
https://github.com/uhub/awesome-erlang  (current)


"New technologies have their best chance 
 a) immediately after a disaster or
 b) at the start of a new project"
                                       Joe Armstrong

https://lfe.io/learn/   Resources for Learning LFE
--- LFE ---
   The LFE Tutorial
   Casting SPELs in LFE
   SICP LFE edition

--- Erlang & OTP ---
   F.Hebert: "Learn You Some Erlang for Great Good!"
   F.Cesarini, S.Vinoski: "Designing for Scalability with Erlang/OTP"
   M.Logan, E.Merritt, R.Carlsson: "Erlang and OTP in Action"

--- In Production ---
   https://adoptingerlang.org  Adopting Erlang
      T.Sloughter, F.Hebert, E.Vigil-McClanahan
   https://erlang-in-anger.com  Erlang in Anger
      F.Hebert

--- Lisp Internals ---
   Ch.Queinnec: "Lisp in Small Pieces"
   D.Hoyte: "Let Over Lambda"

--- Lisp Reference ---
   http://www.lispworks.com/documentation/HyperSpec/Front/Contents.htm
      Common Lisp Hyperspec
   http://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf
      The Moonual

